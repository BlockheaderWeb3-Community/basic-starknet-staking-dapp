#[test]
#[should_panic(expected: ('receipt tkn allowance too low',))]
fn test_insufficient_receipt_token_allowance_for_withdraw() {
    let (staking_contract_address, bwc_contract_address, receipt_contract_address, reward_contract_address) =
        deploy_contract();
    let receipt_dispatcher = IERC20Dispatcher { contract_address: receipt_contract_address };
    let stake_dispatcher = IStakeDispatcher { contract_address: staking_contract_address };
    let bwc_dispatcher = IERC20Dispatcher { contract_address: bwc_contract_address };
    let reward_dispatcher = IERC20Dispatcher { contract_address: reward_contract_address };


    start_prank(CheatTarget::One(bwc_contract_address), Account::admin());
    bwc_dispatcher.transfer(Account::user1(), 35);
    stop_prank(CheatTarget::One(bwc_contract_address));

    start_prank(CheatTarget::One(receipt_contract_address), Account::admin());
    receipt_dispatcher.transfer(staking_contract_address, 20);
    stop_prank(CheatTarget::One(receipt_contract_address));

     start_prank(CheatTarget::One(reward_contract_address), Account::admin());
    reward_dispatcher.transfer(staking_contract_address, 50);
    stop_prank(CheatTarget::One(reward_contract_address));

    start_prank(CheatTarget::One(bwc_contract_address), Account::user1());
    bwc_dispatcher.approve(staking_contract_address, 10);
    stop_prank(CheatTarget::One(bwc_contract_address));

   

    start_prank(CheatTarget::One(staking_contract_address), Account::user1());
    stake_dispatcher.stake(6);

       start_warp(CheatTarget::One(staking_contract_address), get_block_timestamp() + 240);
       stake_dispatcher.withdraw(6);
    
}